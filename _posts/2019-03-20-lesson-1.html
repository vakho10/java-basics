---
layout: default
title:  "გაკვეთილი N1"
date: 2019-03-20 09:00:00 +0400
categories: lesson
---

<h1 class="text-center">რა არის ჯავა?</h1>
<p>სანამ უშუალოდ დავიწყებდეთ პროგრამირების რომელიმე ენაში კოდის წერას, ან რაიმე სუპერ-გრანდიოზულ პროექტზე მუშაობას, კარგი იქნებოდა გაგვეგო ამ ენის ისტორია და მისი მუშაობის პრინციპი (იგივე ე.წ. არქიტექტურა). </p>		

<!--more-->

<hr />

<h2>შესავალი</h2>
<p>Java (რომელსაც მომავალში მოვიხსენიებთ ქართულად, როგორც "ჯავას") არის ერთ-ერთი გავრცელებული და პოპულარული
  პროგრამირების ენა. იგი სინტაქსით ჰგავს C++-სა და C#-ს.</p>
<p>ეს სამივე ერთ ოჯახს მიეკუთვნება, რომლებსაც ობიექტზე (ან
  ობიექტებზე) ორიენტირებულ ენებს ეძახიან. ასეთი ენების იდეა მარტივია - <mark>პროგრამაში ვიყენებთ ობიექტებს.</mark></p>
<p>ჯავა არის მძიმედ ობიექტზე ორიენტირებული ენა, რაც იმას ნიშნავს რომ <u>ჯავაში ყველაფერი ობიექტია</u>. რათქმაუნდა,
  გვაქვს პრიმიტიული ტიპები, ოპერატორები, გასაღები სიტყვები (keywords), მაგრამ ყველგან ვიყენებთ ობიექტებს.</p>
<p>მაგალითად, შეხედეთ შემდეგ კოდს, რომელიც ბეჭდავს <code>Hello, world!</code>-ს კონსოლში:</p>
{% highlight java  %}
public class HelloWorld
{
	public static void main(String[] args) {
		System.out.println("Hello World!");
	}
}
{% endhighlight %}
<p>ამ კოდში დიდი ყურადღება არ გაამახვილოთ გასაღებ სიტყვებზე. უბრალოდ ნახეთ, რომ <code>Hello, world!</code>
  შეტყობინების გამოსატანად დაგვჭირდა ობიექტის განსაზღვრა.</p>

<h2>წარმოშობა</h2>
<p>ჯავას შექმნა კანადელმა <a href="https://en.wikipedia.org/wiki/James_Gosling">ჯეიმს გოსლინგმა</a> 1995 წელს <a href="https://en.wikipedia.org/wiki/Sun_Microsystems">სანს მიკროსისტემში</a> (Sun Microsystems).</p>
<p>ჯავას მთავარი მოტივი იყო ყოფილიყო პლატფორმისგან დამოუკიდებელი (აგნოსტური), რაც ნიშნავს შემდეგს:</p>
<p class="text-center"><mark>დააკომპილირე ერთ პლატფორმაზე და გაუშვი სადაც გინდა (write once, run anywhere).</mark></p>

<h2>არქიტექტურა</h2>
<p>ჯავას მულტიპლატფორმულობას უზრუნველყოფს JVM (Java Virtual Machine), რომელიც, მარტივად რომ ვთქვათ, არის ერთგვარი <u>თარჯიმანი აპლიკაცია</u>, რომელიც დაკომპილირებულ ჯავას კოდის ინსტრუქციებს უთარგმნის ოპერაციულ სისტემას.</p>
<p>დაკომპილირებულ ჯავას კოდს ეძახიან "ბაიტკოდს" (bytecode) და იგი მსგავსია ასემბლის ინსტრუქციებისა. ინტერპრეტატორი (ანუ JVM პროგრამა) კითხულობს ჯავას ბაიტკოდს და უშვებს მას სამიზნე ოპერაციულ სისტემაზე.</p>
<p>პროცესი შეგვიძლია ვიზუალურადაც აღვწეროთ:</p>
<img class="img-thumbnail" src="https://aboullaite.me/content/images/2017/08/jit.png" />
<p>მოდით გავეცნოთ შემდეგ დიდ სამეულს: JVM, JRE, JDK. აქედან, JVM უკვე ვახსენეთ, მაგრამ მაინც:</p>
<ul>
  <li>JVM - ჯავას ვირტუალური მანქანა (თარჯიმანი პროგრამა), რომელიც კოდს უშვებს ოპერაციულ სისტემაში.</li>
  <li>JRE (Java Runtime Environment) = <mark>JVM + ჯავას ბიბლიოთეკის ფაილები</mark>. <u>გარემო</u>, რომელშიც ჯავას კოდი ეშვება.</li>
  <li>JDK (Java Development Kit) = <mark>JRE + ხელსაწყოები</mark> (მაგალითად, როგორიცაა ჯავას კომპილერი: javac და ა. შ.)</li>
</ul>
<p>აქედან აზრი, დაკომპილირებული ჯავას <u>ბაიტკოდის გასაშვებად</u> საკმარისია ოპერაციულ სისტემაში გვეყენოს JRE.</p>
<p>თუ გვსურს ჯავაზე კოდის წერა, დაკომპილირება და გაშვება, მაშინ სისტემაზე უნდა გვეყენოს JDK.</p>

<h2>დეველოპმენტის გარემოები</h2>
<p>ჩვენ შეგვიძლია ჯავას კოდის დაწერა, დაკომპილირება და გაშვება ხელით, notepad-ის ან notepad++-ის (ან რომელიმე
  სხვა ტექსტური რედაქოტრის) გამოყენებით, მაგრამ როგორც C++-ისთვის არსებობს Visual Studio-ს IDE (Integrated Development
Environment), ასევე, ჯავასთვისაც არის ბევრი მოქნილი და საყვარელი გარემები კოდის საწერად.</p>
<p>ტოპ 3 ყველაზე ცნობილი გარემოა:
  <a href="https://www.jetbrains.com/idea/">IntelliJ IDEA</a>, <a href="https://www.eclipse.org/ide/">Eclipse IDE</a>
  და <a href="https://netbeans.org/">Netbeans</a>.</p>
<p>თუ რომელ გარემოში დაწერთ ჯავას კოდს ეს თქვენზეა დამოკიდებული, მაგრამ ჩამოთვლილი სამეული პოპულარობის მიხედვით
  დავალაგე. ყველაზე პოპულარული IntelliJ არის. იგი ფასიანია, აქვს უფასო სტუდენტური და უფასო Community ვერსია. Community
  ვერსია საკმარისია ჩვენი საბაზისო კურსისთვის.</p>

<h2>ვერსიები</h2>
<p>ჯავას ვერსიები 1.8 ვერსიამდე იზრდებოდა მეათედით: 1.4, 1.5, 1.6 და ა. შ.</p>
<p>1.8 ვერსიიდან მოყოლებული ვერსიების აღნიშვნები შეიცვალა. 1.8 ვერსია იგივე 8 ვერსია გახდა და ახალი ვერსიები უკვე
  ერთეულებით იზრდება. მიმდინარე ვერსია, მაგალითად არის 12.</p>
<p>გაითვალისწინეთ, რომ ჯავას სტაბილური ვერსიები, რომელთაც ორაკლი დიდხნიან მხარდაჭერას უწევს არის ვერსია 8 და ვერსია 11.
  თუ კოდს ვწერთ, მაშინ აუცილებლად ასეთ ვერსიებზე უნდა ვწეროთ.</p>

<h2>თავდაპირველი წესები/შეთანხმებები</h2>
<p>ჯავას კოდი იწერება *.java ფაილში და დაკომპილირებული ბაიტკოდი იწერება შესაბამის *.class ფაილში. ეს *.class ფაილი არ
  არის გასაღებ სიტყვა class-თან კავშირში. უბრალოდ შეთანხმებულია, რომ ბაიტკოდი იწერება .class გაფართოების ფაილში.</p>
<p>*.java ფაილში უნდა გავითვალისწინოთ შემდეგი წესები:</p>
<ul>
  <li>ფაილის სახელი (გაფართოების გარეშე) უნდა ემთხვეოდეს ამ ფაილში აღწერილი public კლასის სახელს.</li>
  <li>ფაილში აუცილებლად უნდა იყოს მხოლოდ ერთი public კლასი (მაგალითად, public class Person {}). არა-public კლასი შეგვიძლია გვქონდეს რამდენიც გვინდა.</li>
  <li>ფაილში პაკეტის აღწერა (თუ ასეთი არსებობს) უნდა იყოს ყველაზე პირველი.</li>
  <li>ფაილში პაკეტის აღწერილობა უნდა ემთხვეოდეს ფაილურ სისტემაში ფოლდერების სტრუქტურას (სადაც წერტილი არის იგივე ფაილური სეპარატორი, '/' სიმბოლო).</li>
  <li>ფაილში import წინადადებები (თუ ასეთები საჭიროა) უნდა იყვნენ პაკეტის აღწერილობასა და კლასების აღწერილობებს შორის.</li>
</ul>
<p>მაგალითად, მოვიყვანოთ პიროვნების კლასი:</p>
{% highlight java  %}
// ge/tsu/Person.java
package ge.tsu;

import java.lang.String;

public class Person {

	String firstName;
	String lastName;
	int age;

	void print() {
		System.out.println("Firstname: " + firstName 
				+ ", Lastname: " + lastName + ", Age: " + age + ". ");
	}
}
{% endhighlight %}
<p>იმ შემთხვევაში თუ კოდის სინტაქსის (და ლოგიკის) წესებს არ დავემორჩილებით, მაშინ <mark>კოდი არ დაკომპილირდება</mark>.</p>

<h2>main მეთოდი</h2>
<p>main მეთოდი (იგივე მთავარი მეთოდი) არის ყველა პროგრამის შემავალი წერტილი, ის ფუნქცია, რომელიც პროგრამის გაშვებისას სრულდება.</p>
<p>სხვადასხვა პროგრამირების ენებში სხვადასხვა წესებია main მეთოდთან დაკავშირებით. მაგალითად, C++-ში მთავარი მეთოდი
  შეიძლება იყოს მხოლოდ ერთი ცალი ერთი პროგრამისთვის. <u>ჯავაში შეგვიძლია გვქონდეს ერთი main მეთოდი ერთ *.java
    ფაილში</u>, რადგანაც ჯავას გაშვება ხდება ერთი, რომელიმე დაკომპილირებული *.class ფაილის სახელის მითითებით.</p>
<p>ეს არის შედარებით მოქნილი სტრუქტურა, რადგანაც შეგვიძლია პროგრამაში რამდენიმე შემავალი წერტილი გვქონდეს და ისინი ვცვალოთ გაშვების მომენტში ჩვენ გემოზე.</p>
<p>მთავარი მეთოდის ხელმოწერა (პროტოტიპი, ან იგივე სახე) უნდა იყოს აუცილებლად შემდეგნაირი:</p>
<p><code>public static void main(String[] args)</code></p>
<p>გასათვალისწინებელია, რომ პარამეტრის სახელს ყურადღება არ ექცევა. მთავარია სხვა დანარჩენი დაემთხვეს. წინააღმდეგ
  შემთხვევაში მეთოდი არ იქნება შემავალი მეთოდი და პროგრამა მას უბრალო მეთოდად ჩათვლის.</p>
<p>მაგალითი მთავარი მეთოდისა:</p>
{% highlight java  %}
public static void main(String[] args) {
  // Some code here...
}
{% endhighlight %}
<p>მთავარ მეთოდში გამოყენებული გასაღები სიტყვებს ამჯერად შეგიძლიათ ყურადღება არ მიაქციოთ. თუ გაინტერესებთ, მაშინ უბრალოდ
	გეტყვით, რომ <code>public</code> აღნიშნავს მეთოდის ყველასთვის ხილვადობას (კოდის ყველა ფრაგმენტიდან და ა. შ.),
	<code>static</code> გულისმობს იმას, რომ ობიექტის შექმნა არაა საჭირო მეთოდის გამოსაძახებლად - იგი სტატიკურია
	(ყველასათვის ყოველთვის არსებობს). დანარჩენები უკვე თქვენითაც იცით.</p>

<h2>მასივი (როგორც ობიექტი)</h2>
<p>როგორც ვთქვით, ჯავაში ყველაფერი ობიექტია და ამიტომაც, სწორად მიხვდით - მასივიც ობიექტია.</p>
<p>ჯავაში მასივის განსაზღვრების წესი ჰგავს C++-ისას. ზოგადად, ჯავას სინტაქსი მსგავსია C++-ის სინტაქსისა და მისი ათვისება
  არ გაგიჭირდებათ. მსგავსება მეტია ვიდრე განსხვავება.</p>
<p>მასივთან დაკავშირებული ოპერაციები შემდეგნაირია:</p>
{% highlight java  %}
int[] nums = new int[3]; // Declare
		
// Assign...
nums[0] = 1; 
nums[1] = 2;
nums[2] = 3;

// Declare and assign at the same time
int[] nums2 = new int[] { 1, 2, 3 }; // Short
int[] nums3 = { 1, 2, 3 }; // Shorter 

/*
  * Multidimensional array
  */
int[][] matrix = new int[3][];
matrix[0] = new int[3];
matrix[1] = new int[3];
matrix[2] = new int[3];

for (int i = 0; i < matrix.length; i++) {
  for (int j = 0; j < matrix[i].length; j++) {
    matrix[i][j] = i + j;
  }
}		

// Shorter
int[][] matrix2 = new int[][] { { 0, 1, 2 }, { 3, 4, 5 }, { 6, 7, 8 }, };

// Even shorter
int[][] matrix3 = { { 0, 1, 2 }, { 3, 4, 5 }, { 6, 7, 8 }, };
{% endhighlight %}
<p>რადგანაც მასივი ობიექტია, მას აქვს ველი სახელად length, რომელიც შეიცავს მის ზომას. გვახსოვდეს, რომ მასივის ზომა კონსტანტურია და მისი ცვლილება პროგრამის მსვლელობისას შეუძლებელია.</p>
<p>მასივის ერთ ხაზში ინიციალიზაცია და მინიჭება შესაძლებელია ტიპის მითითების გარეშეც. კომპილერი (პროგრამა, რომელიც კოდს აკომპილირებს) ჭკვიანია და მიმთითებლის ტიპის მიხედვით იცის რა ტიპის მასივიც იქმნება.</p>
<p>მასივის ერთ ხაზში ინიციალიზაციისას შეგვიძლია ჩამონათვალის ბოლოს გამოვიყენოთ ','. </p>

<h2>სადემონსტრაციო მაგალითი</h2>
<p>მოდით გამოვიყენოთ ამ თავში ნასწავლი ინფორმაცია და დავწეროთ მარტივი მაგალითი. დავწეროთ პროგრამა, რომელიც Bubble Sort ალგორითმით დაალაგებს ელემენტებს ზრდადობით:</p>
{% highlight java  %}
package ge.tsu;

public class BubbleSort {

	public static void main(String[] args) {
		int[] nums = {1, -2, 12, 56, 3, 2};
		printArray(nums); 
		bubbleSort(nums); // Sort array
		printArray(nums); // Print sorted
	}
	
	static void bubbleSort(int[] nums) {
		for (int i = 0; i < nums.length; i++) {
			for (int j = i + 1; j < nums.length; j++) {
				if (nums[j] < nums[i]) {
					// Swap numbers					
					int tmpNum = nums[j];
					nums[j] = nums[i];
					nums[i] = tmpNum;
				}
			}
		}
	}
	
	static void printArray(int[] nums) {
		System.out.print("[ ");
		for (int i = 0; i < nums.length; i++) {
			System.out.print(nums[i]);
			if (i != nums.length - 1) {
				System.out.print(", ");
			}
		}
		System.out.println(" ]");
	}
}
{% endhighlight %}
<p>P. S. სახლში შეგიძლიათ დაწეროთ იგივე კოდი სხვა სორტირების ალგორითმის გამოყენებით. მაგალითად, Selection Sort ან Insertion Sort.</p>